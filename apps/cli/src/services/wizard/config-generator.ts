import { writeFileSync, readFileSync, existsSync } from 'node:fs';
import * as path from 'node:path';
import { DetectionResult } from '@dev-quality/core';

export interface GeneratorOptions {
  projectPath: string;
  detectionResult?: DetectionResult;
  action?: 'create' | 'replace' | 'merge';
}

export interface GeneratedConfig {
  filePath: string;
  content: string;
  action: 'created' | 'replaced' | 'merged' | 'skipped';
}

/**
 * Base configuration generator class
 */
export abstract class ConfigGenerator {
  protected projectPath: string;
  protected detectionResult?: DetectionResult | undefined;

  constructor(options: GeneratorOptions) {
    this.projectPath = path.resolve(options.projectPath);
    this.detectionResult = options.detectionResult;
  }

  abstract generate(action?: 'create' | 'replace' | 'merge'): Promise<GeneratedConfig>;

  protected readExistingConfig(filePath: string): string | undefined {
    try {
      if (existsSync(filePath)) {
        return readFileSync(filePath, 'utf-8');
      }
      return undefined;
    } catch (error) {
      throw new Error(
        `Failed to read existing config at ${filePath}: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  protected writeConfig(filePath: string, content: string): void {
    try {
      writeFileSync(filePath, content, 'utf-8');
    } catch (error) {
      throw new Error(
        `Failed to write config to ${filePath}: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  protected sanitizePath(filePath: string): string {
    const resolved = path.resolve(this.projectPath, filePath);

    // Prevent path traversal attacks - ensure resolved path is within project
    if (!resolved.startsWith(this.projectPath)) {
      throw new Error(`Invalid path: ${filePath} is outside project directory`);
    }

    return resolved;
  }
}

/**
 * Bun test configuration generator
 */
export class BunTestConfigGenerator extends ConfigGenerator {
  async generate(action: 'create' | 'replace' | 'merge' = 'create'): Promise<GeneratedConfig> {
    const configPath = this.sanitizePath('bunfig.toml');
    const existingConfig = this.readExistingConfig(configPath);

    let content: string;
    let resultAction: GeneratedConfig['action'];

    if (existingConfig && action === 'merge') {
      content = this.mergeConfig(existingConfig);
      resultAction = 'merged';
    } else {
      content = this.createConfig();
      resultAction = existingConfig ? 'replaced' : 'created';
    }

    this.writeConfig(configPath, content);

    return {
      filePath: configPath,
      content,
      action: resultAction,
    };
  }

  private createConfig(): string {
    const testPaths = this.detectionResult?.structure.testDirectories ?? ['./tests'];

    return `# Bun Test Configuration
# Generated by DevQuality Setup Wizard

[test]
# Test file patterns
preload = ["./test-setup.ts"]
coverage = true
coverageThreshold = 80

# Test execution
bail = false
timeout = 5000

# Test discovery patterns
testPathPatterns = [${testPaths.map(p => `"${p}/**/*.test.{ts,tsx}"`).join(', ')}]
`;
  }

  private mergeConfig(existingConfig: string): string {
    // Simple merge: append our test configuration if [test] section doesn't exist
    if (existingConfig.includes('[test]')) {
      return existingConfig; // Keep existing test config
    }

    return `${existingConfig}\n\n${this.createConfig()}`;
  }
}

/**
 * ESLint configuration generator
 */
export class ESLintConfigGenerator extends ConfigGenerator {
  async generate(action: 'create' | 'replace' | 'merge' = 'create'): Promise<GeneratedConfig> {
    // Try flat config first (eslint.config.js)
    const flatConfigPath = this.sanitizePath('eslint.config.js');
    const legacyConfigPath = this.sanitizePath('.eslintrc.json');

    const existingFlatConfig = this.readExistingConfig(flatConfigPath);
    const existingLegacyConfig = this.readExistingConfig(legacyConfigPath);

    let content: string;
    let configPath: string;
    let resultAction: GeneratedConfig['action'];

    // Prefer flat config
    if (existingFlatConfig || !existingLegacyConfig) {
      configPath = flatConfigPath;
      content = this.createFlatConfig();
      resultAction = existingFlatConfig ? 'replaced' : 'created';

      if (existingFlatConfig && action === 'merge') {
        content = existingFlatConfig; // Keep existing for merge (manual merge needed)
        resultAction = 'merged';
      }
    } else {
      configPath = legacyConfigPath;
      content = this.createLegacyConfig();
      resultAction = 'replaced';
    }

    this.writeConfig(configPath, content);

    return {
      filePath: configPath,
      content,
      action: resultAction,
    };
  }

  private createFlatConfig(): string {
    return `// ESLint Flat Configuration
// Generated by DevQuality Setup Wizard

import js from '@eslint/js';
import typescript from '@typescript-eslint/eslint-plugin';
import typescriptParser from '@typescript-eslint/parser';

export default [
  js.configs.recommended,
  {
    files: ['**/*.ts', '**/*.tsx'],
    languageOptions: {
      parser: typescriptParser,
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
      },
    },
    plugins: {
      '@typescript-eslint': typescript,
    },
    rules: {
      '@typescript-eslint/no-explicit-any': 'error',
      '@typescript-eslint/explicit-function-return-type': 'warn',
      '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
      'no-console': ['warn', { allow: ['warn', 'error'] }],
    },
  },
];
`;
  }

  private createLegacyConfig(): string {
    const config = {
      extends: ['eslint:recommended', 'plugin:@typescript-eslint/recommended'],
      parser: '@typescript-eslint/parser',
      plugins: ['@typescript-eslint'],
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
      },
      rules: {
        '@typescript-eslint/no-explicit-any': 'error',
        '@typescript-eslint/explicit-function-return-type': 'warn',
        '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
        'no-console': ['warn', { allow: ['warn', 'error'] }],
      },
    };

    return JSON.stringify(config, null, 2);
  }
}

/**
 * Prettier configuration generator
 */
export class PrettierConfigGenerator extends ConfigGenerator {
  async generate(action: 'create' | 'replace' | 'merge' = 'create'): Promise<GeneratedConfig> {
    const configPath = this.sanitizePath('.prettierrc.json');
    const existingConfig = this.readExistingConfig(configPath);

    let content: string;
    let resultAction: GeneratedConfig['action'];

    if (existingConfig && action === 'merge') {
      content = this.mergeConfig(existingConfig);
      resultAction = 'merged';
    } else {
      content = this.createConfig();
      resultAction = existingConfig ? 'replaced' : 'created';
    }

    this.writeConfig(configPath, content);

    // Also create .prettierignore
    const ignoreConfigPath = this.sanitizePath('.prettierignore');
    if (!existsSync(ignoreConfigPath)) {
      this.writeConfig(ignoreConfigPath, this.createIgnoreFile());
    }

    return {
      filePath: configPath,
      content,
      action: resultAction,
    };
  }

  private createConfig(): string {
    const config = {
      semi: true,
      trailingComma: 'es5',
      singleQuote: true,
      printWidth: 100,
      tabWidth: 2,
      useTabs: false,
      arrowParens: 'always',
      endOfLine: 'lf',
    };

    return JSON.stringify(config, null, 2);
  }

  private mergeConfig(existingConfig: string): string {
    try {
      const existing = JSON.parse(existingConfig);
      const defaults = JSON.parse(this.createConfig());

      // Merge: keep existing values, add missing defaults
      const merged = { ...defaults, ...existing };

      return JSON.stringify(merged, null, 2);
    } catch {
      // If parsing fails, return new config
      return this.createConfig();
    }
  }

  private createIgnoreFile(): string {
    return `# Prettier ignore file
# Generated by DevQuality Setup Wizard

node_modules
dist
build
output
coverage
*.min.js
*.min.css
package-lock.json
yarn.lock
pnpm-lock.yaml
`;
  }
}

/**
 * TypeScript configuration generator
 */
export class TypeScriptConfigGenerator extends ConfigGenerator {
  async generate(action: 'create' | 'replace' | 'merge' = 'create'): Promise<GeneratedConfig> {
    const configPath = this.sanitizePath('tsconfig.json');
    const existingConfig = this.readExistingConfig(configPath);

    let content: string;
    let resultAction: GeneratedConfig['action'];

    if (existingConfig && action === 'merge') {
      content = this.mergeConfig(existingConfig);
      resultAction = 'merged';
    } else {
      content = this.createConfig();
      resultAction = existingConfig ? 'replaced' : 'created';
    }

    this.writeConfig(configPath, content);

    return {
      filePath: configPath,
      content,
      action: resultAction,
    };
  }

  private createConfig(): string {
    const srcDirs = this.detectionResult?.structure.sourceDirectories ?? ['./src'];
    const testDirs = this.detectionResult?.structure.testDirectories ?? ['./tests'];

    const config = {
      compilerOptions: {
        target: 'ES2022',
        module: 'ESNext',
        lib: ['ES2022'],
        moduleResolution: 'bundler',
        strict: true,
        esModuleInterop: true,
        skipLibCheck: true,
        forceConsistentCasingInFileNames: true,
        resolveJsonModule: true,
        declaration: true,
        declarationMap: true,
        sourceMap: true,
        outDir: './dist',
        rootDir: './',
        baseUrl: './',
        paths: {
          '@/*': ['./src/*'],
        },
      },
      include: [...srcDirs, ...testDirs],
      exclude: ['node_modules', 'dist', 'build', 'output'],
    };

    return JSON.stringify(config, null, 2);
  }

  private mergeConfig(existingConfig: string): string {
    try {
      const existing = JSON.parse(existingConfig);
      const defaults = JSON.parse(this.createConfig());

      // Deep merge compilerOptions
      const mergedCompilerOptions = {
        ...defaults.compilerOptions,
        ...existing.compilerOptions,
      };

      const merged = {
        ...defaults,
        ...existing,
        compilerOptions: mergedCompilerOptions,
      };

      return JSON.stringify(merged, null, 2);
    } catch {
      // If parsing fails, return new config
      return this.createConfig();
    }
  }
}
